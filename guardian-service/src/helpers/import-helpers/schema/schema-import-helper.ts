import { IOwner, ISchema, ISchemaDocument, Schema, SchemaCategory } from '@guardian/interfaces';
import { DatabaseServer, PinoLogger, Schema as SchemaCollection } from '@guardian/common';
import { INotifier } from '../../notifier.js';
import { ImportSchemaResult } from './schema-import.interface.js';
import { SchemaImport } from './schema-import.js';
import { checkForCircularDependency } from '../common/load-helper.js';
import { ImportMode } from '../common/import.interface.js';

/**
 * Schema import export helper
 */
export class SchemaImportExportHelper {
    /**
     * Export schemas
     * @param ids Schemas ids
     * @returns Schemas to export
     */
    public static async exportSchemas(ids: string[]): Promise<SchemaCollection[]> {
        const schemas = await DatabaseServer.getSchemasByIds(ids);
        const map = new Map<string, SchemaCollection>();
        for (const schema of schemas) {
            map.set(schema.iri, schema);
        }

        const defs = new Set<string>();
        for (const schema of schemas) {
            const keys = SchemaImportExportHelper.getDefs(schema);
            for (const iri of keys) {
                if (!map.has(iri)) {
                    defs.add(iri);
                }
            }
        }

        const sub = await DatabaseServer.getSchemas({ iri: { $in: Array.from(defs) } });
        for (const schema of sub) {
            map.set(schema.iri, schema);
        }

        return Array.from(map.values());
    }

    /**
     * Get defs
     * @param schema
     */
    public static getDefs(schema: ISchema): string[] {
        try {
            let document: ISchemaDocument = schema.document;
            if (typeof document === 'string') {
                document = JSON.parse(document);
            }
            if (!document.$defs) {
                return [];
            }
            return Object.keys(document.$defs);
        } catch (error) {
            return [];
        }
    }

    /**
     * Get defs
     * @param schema
     */
    public static getDefDocuments(schema: ISchema): ISchemaDocument[] {
        try {
            let document: ISchemaDocument = schema.document;
            if (typeof document === 'string') {
                document = JSON.parse(document);
            }
            if (document && document.$defs) {
                return Object.values(document.$defs);
            }
            return [];
        } catch (error) {
            return [];
        }
    }

    /**
     * Validate and update schema defs
     *
     * @param target Schema iri
     * @param allSchemas Schemas
     * @param validatedSchemas Schemas
     */
    public static validateDefs(
        target: string,
        allSchemas: Schema[],
        validatedSchemas: Map<string, Schema>
    ): string {
        if (validatedSchemas.has(target)) {
            return null;
        }

        const schema = allSchemas.find((s) => s.iri === target);
        if (!schema) {
            return 'Invalid defs';
        }

        if (checkForCircularDependency(schema)) {
            return `There is circular dependency in schema: ${target}`;
        }

        let valid = true;
        for (const field of schema.fields) {
            if (field.isRef) {
                const error = SchemaImportExportHelper.validateDefs(field.type, allSchemas, validatedSchemas);
                if (error) {
                    field.type = null;
                    valid = false;
                }
            }
        }
        schema.update(schema.fields, schema.conditions);
        schema.updateRefs(allSchemas);

        validatedSchemas.set(target, schema);

        if (!valid) {
            return 'Invalid defs';
        } else {
            return null;
        }
    }

    /**
     * Import schema by files
     * @param files
     * @param user
     * @param options
     * @param notifier
     */
    public static async importSchemaByFiles(
        files: ISchema[],
        user: IOwner,
        options: {
            topicId: string,
            category: SchemaCategory,
            skipGenerateId?: boolean,
            outerSchemas?: { name: string, iri: string }[],
            mode?: ImportMode
        },
        notifier: INotifier,
        userId: string | null
    ): Promise<ImportSchemaResult> {
        const helper = new SchemaImport(options.mode, notifier);
        helper.addExternalSchemas(options.outerSchemas);
        return helper.import(files, user, options, userId);
    }
    /**
     * Import schemas by messages
     * @param owner
     * @param messageIds
     * @param topicId
     * @param notifier
     * @param logger
     */
    public static async importSchemasByMessages(
        messageIds: string[],
        user: IOwner,
        options: {
            topicId: string,
            category: SchemaCategory,
            mode?: ImportMode
        },
        notifier: INotifier,
        logger: PinoLogger,
        userId: string | null
    ): Promise<ImportSchemaResult> {
        const helper = new SchemaImport(options.mode, notifier);
        return helper.importByMessage(messageIds, user, options, logger, userId);
    }

    /**
     * Import schema by files
     * @param files
     * @param user
     * @param options
     * @param notifier
     */
    public static async importSystemSchema(
        files: ISchema[],
        user: IOwner,
        options: {
            topicId: string,
            category: SchemaCategory,
            skipGenerateId?: boolean,
            outerSchemas?: { name: string, iri: string }[],
            mode?: ImportMode
        },
        notifier: INotifier,
        userId: string | null
    ): Promise<ImportSchemaResult> {
        const helper = new SchemaImport(options.mode, notifier);
        helper.addExternalSchemas(options.outerSchemas);
        return helper.importSystem(files, user, options, userId);
    }
}